/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.3 phantoms.glb --transform
*/
import { MathUtils } from "three";
import * as THREE from "three";
import React, { useRef, useLayoutEffect, useState } from "react";
import { OrbitControls, useGLTF, useScroll } from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import gsap from "gsap";
import { TextureLoader, DoubleSide } from "three";
import { ScrollTrigger } from "gsap/ScrollTrigger";
import { getNewSliderCoords } from "./logic/getNewSliderCoords";

export function Slider(props) {
  //   const { nodes, materials } = useGLTF(s
  //     "./models/robot/phantoms-transformed.glb"
  //   );
  gsap.registerPlugin(ScrollTrigger);

  const slider = useRef();
  // const robot = useRef();
  const scroll = useScroll();
  const tl = useRef();

  const scrollTester = useScroll();

  const [hovered, setHovered] = useState(false);
  const [direction, setDirection] = useState(1);

  let highestSlider = 2;

  useFrame((state, delta) => {
    if (tl?.current) tl.current?.seek(scroll?.offset * tl.current.duration());
  });
  useLayoutEffect(() => {
    tl.current = gsap.timeline({
      defaults: { duration: 3, ease: "power1.inOut" },
    });

    getNewSliderCoords(
      props.name,
      tl,
      slider,
      props.index,
      props.numberOfSliders
    );
  }, []);

  // ... inside your Slider component
  const radius = 4; // You can change this value for the shape of the spiral.
  const speed = 0.5; // You can change this value for the speed of the animation.
  const maxHeight = 2;
  const minHeight = -1;

  useFrame((state) => {
    // Calculate new angle based on time.
    const angle = state.clock.getElapsedTime() * speed * direction;

    // Calculate the new position on the spiral
    var x = radius * Math.cos(angle);
    var z = radius * Math.sin(angle);
    var y = direction * angle * 0.1; // This part is reversed when direction is -1

    slider.current.position.set(x, y, z);

    // When the slider reaches a certain point, reverse direction
    if (y > maxHeight && direction === 1) {
      console.log("yes!");
      setDirection(-1);
    } else if (y < minHeight && direction === -1) {
      console.log("no!!");
      setDirection(1);
    }
  });

  return (
    <>
      {/* <OrbitControls /> */}

      <mesh
        ref={slider}
        position={props.sp}
        rotation={[0, 0, 0]} //{startingRotation(props.index)}
        onClick={() => {
          // console.log(slider.current.position);
          // console.log(slider.current.rotation);
        }}
        onPointerOver={() => setHovered(true)}
        onPointerOut={() => setHovered(false)}
        name={props.name}
      >
        <planeGeometry args={[2.5, 1.4, 1]} />
        <meshBasicMaterial
          side={DoubleSide}
          map={props.texture}
          // opacity={1}
          transparent={props.isTransparent}
          // color={"black"}
        ></meshBasicMaterial>
      </mesh>
    </>
  );
}

export const Helix = () => {
  const helixRef = useRef();
  var radius = 10;
  var turns = 3;
  var objPerTurn = 30;

  var angleStep = (Math.PI * 2) / objPerTurn;
  var heightStep = 0.5;
  let position;

  const geo = new THREE.BoxGeometry(2, 3, 0.1);
  const mat = new THREE.MeshBasicMaterial({
    color: Math.random() * 0x888888 + 0x888888,
  });

  const arr = new Array(120).fill(1);

  const testArr = arr.map((item, i) => {
    const positionInHelix = [
      Math.cos(angleStep * i) * radius,
      heightStep * i - 30,
      Math.sin(angleStep * 0) * radius - 10,
    ];
    return (
      <mesh
        position={positionInHelix}
        // onClick={() => console.log(positionInHelix)}
        // rotation={[0]}
        key={i}
        geometry={geo}
        material={mat}
        ref={helixRef}
      >
        {/* <boxGeometry args={[2, 3, 0.1]} />
        <meshBasicMaterial
          color={Math.random() * 0x888888 + 0x888888}
        ></meshBasicMaterial> */}
      </mesh>
    );
  });

  return testArr;
};
const startingRotation = (idx) => {
  // if (idx == 0) {
  //   return [0, Math.PI * 5, -0.2];
  // }
  // if (idx == 1) {
  //   return [0, -1.5, Math.PI * 5];
  // }
  // if (idx == 2) {
  //   return [0, 0, 0];
  // }
  // if (idx == 3) {
  //   return [0, Math.PI * 1.2, -0.3];
  // }
  // if (idx == 4) {
  //   return [0, Math.PI / 1.6, -0.5];
  // }
  return [0, 0, 0];
};
